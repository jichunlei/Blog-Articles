https://github.com/JosephZhu1983/java-common-mistakes

# 01 | 使用了并发工具类库，线程安全就高枕无忧了吗？

* `ThreadLocal`在使用需要在业务结束时清理掉其中的数据，否则在线程复用的场景中会发生数据串用造成的缺陷。
* 并发工具类并非万能，它只能保证在原子性的API调用层是线程安全的，对于复合逻辑还得需要靠自己的额外加锁处理才能保证线程安全。

# 02 | 代码加锁：不要让“锁”事成为烦心事

* `synchronized`加锁时需要弄清楚当前锁的是实例级别还是类级别。
  * 修饰类或静态方法时，此时锁为类级别
  * 修饰实例或实例方法，锁为实例级别。
* 加锁的时候需要考虑锁的粒度问题。尽可能地将锁的粒度降到最低，从而提高程序的执行效率。
* 业务逻辑需要特别注意死锁的情况。一般处理方式为设置超时时间自动释放，或者对锁的获取设置一定的获取顺序。

# 03 | 线程池：业务代码最常用也最容易犯错的组件

* 尽量避免使用Executors 类提供的一些快捷声明线程池的方法，这些方法虽然方便，但是隐藏了线程池的参数信息。因此在使用的时候我们应该根据实际场景自定义合理的线程池参数（核心线程数，最大线程数，阻塞队列大小，线程回收策略，拒绝策略等）
* 实际项目中，线程池的创建不应该太频繁，尽量将同场景下的业务处理使用同一线程池。过多地创建线程池比过多地创建线程还要糟糕。
* 对于执行较慢、数量不大的IO任务，可以考虑使用更多的线程数，而不需要太大的队列
* 对于吞吐量较大的计算型任务，线程数不宜过多（一般为CPU核数或CPU核数*2，如果任务本身是CPU绑定的任务，那么过多的线程只会增加线程切换的开销，并不能提升吞吐量），并且需要较大的队列。

# 04 | 连接池：别让连接池帮了倒忙

* 连接池一定是复用的，否则代价会比每次创建单一对象更大。
  * 创建连接池的时候一般会预先创建多个连接，大多数连接池在为了考虑性能问题，都会设置一个最小的连接数。因此当我们创建一个连接池时，本质是创建了多个连接。
  * 连接池除了连接外，还会有一些管理模块。例如闲置连接处理模块，这部分一般会使用独立线程管理。因此启动一个线程池相当于启动了多个线程。
  * 连接池使用完成如果不释放，还可能会导致线程泄露。
* 连接池的配置参数应该根据实际的业务场景配置

# 05 | HTTP调用：你考虑到超时、重试、并发了吗？

* 两个重要的超时参数

  * 连接超时参数（`ConnectTimeout`）：用户配置建立连接的最长等待时间。
  * 读取超时参数（`ReadTimeout`）：控制Socket上读取数据的最长等待时间。

* 服务器端接收到请求，如Tomcat，会将请求交给线程池去处理，即使网络层面的超时和断开，也不会断开服务端的执行。所以请求超时，服务端执行不会断开

* 读取超时指的是，向Socket写入数据后，我们等到Socket返回数据的超时时间，其中包含的时间或者说绝大部分的时间，是服务端处理业务逻辑的时间。

* 超时时间的设置一方面需要考虑本身业务系统的响应要求，同时也要考虑关联的下游系统的响应时间

* 默认情况下feign的读取超时是1秒，我们可以通过配置进行修改

  ```properties
  #配置超时时间均为3s
  feign.client.config.default.readTimeout=3000
  feign.client.config.default.connectTimeout=3000
  ```

  注意：feign的连接和读取超时需要一起配置才能生效，否则只配置其中一个是不生效的

* 针对单个feign Client进行配置超时时间，只需要将上面的default替换为Client的name即可

* 可以配置Ribbon组件的参数来修改默认的超时时间

  ```properties
  ribbon.ReadTimeout=4000
  ribbon.ConnectTimeout=4000
  ```

  注意首字母大写

* 如果同时配置Feign和Ribbon的超时，会以Feign为准

# 06 | 20%的业务代码的Spring声明式事务，可能都没处理正确

* 对private方法使用@Transactional 注解，事务不生效。这是因为@Transactional 基于Spring的AOP动态代理机制，无法对private的方法生成代理，因此事务不生效。
* 对内部方法的使用@Transactional 注解，事务不生效。这是因为内部方法的调用的引用是this，没有走代理，因此事务不生效。
* @Transactional 注解默认只对`RuntimeException`和Error进行回滚，不过我们可以手动配置注解的 rollbackFor 和 noRollbackFor 属性来覆盖其默认设置。Spring之所以这么配置，是因为Spring认为受检异常一般属于业务可预知的异常，这种情况下业务可能允许完成，属于一种正常的业务场景。而RuntimeException和Error表示非正常预期的结果，原则上应该需要回滚。
* 针对具体的业务操作的事务传播性，我们需要细化事务的传播方式，即@Transactional 注解的 Propagation 属性