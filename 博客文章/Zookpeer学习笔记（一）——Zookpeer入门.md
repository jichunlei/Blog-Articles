# **一、概述**

## 1. 什么是Zookeeper

`Zookeeper`是一个**分布式开源框架**，提供了**协调分布式应用**的基本服务，它向外部应用暴露一组通用服务——**分布式同步（Distributed Synchronization）**、**命名服务（Naming Service）**、**集群维护（Group Maintenance）**等，简化分布式应用协调及其管理的难度，提供高性能的分布式服务。`ZooKeeper`本身可以以单机模式安装运行，不过它的长处在于通过分布式`ZooKeeper`集群（一个`Leader`，多个`Follower`），基于一定的策略来保证`ZooKeeper`集群的**稳定性**和**可用性**，从而实现分布式应用的**可靠性**。

* Zookeeper是**为别的分布式程序服务**的
* Zookeeper本身就是一个**分布式程序**（只要有半数以上节点存活，zk就能正常服务）
* Zookeeper所提供的服务涵盖：**主从协调、服务器节点动态上下线、统一配置管理、分布式共享锁、统一名称服务等**
* 虽然说可以提供各种服务，但是zookeeper在底层其实只提供了**两个功能**：
  * **管理（存储，读取）**用户程序提交的数据（类似`namenode`中存放的`metadata`）
  * 为用户程序提供数据节点**监听**服务

## 2. 工作机制（简单介绍）

从设计模式角度来说：Zookpeer是一个**基于观察者模式设计**的分布式服务管理框架，它**负责存储和管理大家都关心的数据**，然后**接受观察者的注册**，一旦这些数据的状态发生变化，Zookeeper就将**负责通知已经在Zookeeper上注册的那些观察者**做出相应的反应。

* **Zookeeper=文件系统+通知机制**

# **二、特性**

* **一个Leader，多个Follower**
* **集群中只要有半数以上节点存活，Zookeeper集群就能正常服务**
* **全局数据的一致**：每个server保存一份相同的数据副本，client无论链接到哪个server，展示的数据都是一致的
* **可靠性**：如果消息被其中一台服务器接受，那么将被所有的服务器接受
* **顺序性**：包括全局有序和偏序两种：全局有序是指如果在一台服务器上消息a在消息b前发布，则在所有server上消息a豆浆在消息b前被发布，偏序是指如果以个消息b在消息a后被同一个发送者发布，a必须将排在b前面
* **数据更新原子性**：一次数据更新要么成功，要么失败，不存在中间状态
* **实时性**：`ZooKeeper`保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息

# **三、数据结构**

`ZooKeeper`数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个`ZNode`。每个`Znode`可以类似看作是一个目录，其下可以创建子目录。每一个`Znode`默认能够存储1MB的数据，每个`ZNode`都可以通过其路径唯一标识。

![](http://img.xianzilei.cn/ZooKeeper%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)

在 `ZooKeeper` 中，节点类型可以分为**持久节点（PERSISTENT ）**、**临时节点（EPHEMERAL）**，以及**时序节点（SEQUENTIAL ）**，具体在节点创建过程中，一般是组合使用，可以生成以下 **4 种节点类型**：

* **1）持久化目录节点（PERSISTENT）**

  节点创建后，就一直存在，直到有**删除操作来主动清除**这个节点（不会因为创建该节点的客户端会话失效而消失）。

* **2）持久化顺序编号目录节点（PERSISTENT_SEQUENTIAL）**

  这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在 `ZooKeeper` 中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点**创建的先后顺序**。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中， `ZooKeeper` 会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。

* **3）临时目录节点（EPHEMERAL）**

  和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会**自动被清除**掉（注意，这里提到的是会话失效，而非连接断开）。另外，在临时节点下面不能创建子节点。

* **4）临时顺序编号目录节点（EPHEMERAL_SEQUENTIAL）**

  与持久化顺序编号目录节点同理，只不过是临时节点，客户端会话失效节点就会被自动清除。

# **四、应用场景**

## **1. 数据发布/订阅**

发布者把数据发布到 `ZooKeeper` 的一个或一系列的节点上，供订阅者进行数据订阅，达到**动态获取数据**的目的。常见的场景比如配置中心。

* 配置信息一般有几个特点

  * **数据量小**
  * 数据内容在运行时会发生**动态变化**
  * 集群机器**共享**，配置**一致**

* `ZooKeeper` 采用的是**推拉结合**的方式。

  * **推**: 服务端会推给注册了监控节点的客户端 Wathcer 事件通知
  * **拉**: 客户端获得通知后，然后主动到服务端拉取最新的数据

* **实现步骤**

  * 把配置信息写到一个 `Znode` 上，例如 `/Configuration`
  * 客户端启动初始化阶段读取服务端节点的数据，并且注册一个数据变更的 Watcher
  * 配置变更只需要对 `Znode` 数据进行 set 操作，数据变更的通知会发送到客户端，客户端重新获取新数据，完成配置**动态修改**

  ![](http://img.xianzilei.cn/Zookeeper%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%9B%BE-001.png)

## **2. 负载均衡**

负载均衡就是把对某种资源的访问分摊给不同的设备，从而**减轻单点**的压力。

* 基本实现步骤
  * 首先建立 `Servers` 节点，并建立监听器监视 `Servers` 子节点的状态（用于在服务器增添时及时同步当前集群中服务器列表）
  * 在每个服务器启动时，在 `Servers` 节点下建立**临时子节点** Worker Server，并在对应的字节点下存入服务器的相关信息，包括服务的地址，IP，端口等等
  * 可以**自定义一个负载均衡算法（比如根据访问数分配，每次分配给访问数最少的服务器）**，在每个请求过来时从 `ZooKeeper` 服务器中获取当前集群服务器列表，根据算法选出其中一个服务器来处理请求

## **3. 命名服务**

命名服务就是提供名称的服务。

* `ZooKeeper` 的命名服务有两个应用方面：
  * 1）提供类 `JNDI` 功能，可以把系统中各种服务的名称、地址以及目录信息存放在 `ZooKeeper`，需要的时候去 `ZooKeeper` 中读取；
  * 2）制作分布式的序列号生成器

## **4. 分布式协调/通知**

`ZooKeeper`中特有的 `Watcher`注册于**异步通知机制**，能够很好地实现分布式环境下不同机器，甚至不同系统之间的**协调**和**通知**，从而实现对数据变更的**实时处理**。通常的做法是不同的客户端对`ZooKeeper`上同一个数据节点进行`Watcher`注册，监听数据节点的变化（包括节点本身和子节点），若数据节点发生变化，那么所有订阅的客户端都能够接受到相应的Watcher通知，并作出相应的处理。

* 在绝大多数分布式系统中，系统机器间的通信无外乎**心跳检测**、**工作进度汇报**和**系统调度**。这三种类型的机器通信方式都可以使用`ZooKeeper`来实现：
  * **心跳检测**：不同机器间需要检测到彼此知否在正常运行，可以使用`ZooKeeper`实现机器间的心跳检测，基于其临时节点特性（临时节点的生存周期是客户端会话，客户端若宕机后，其临时节点自然不再存在），可以让不同机器都在`ZooKeeper`的指定节点下创建临时子节点，不同的机器之间可以根据这个临时自己点来判断对应的客户端机器是否存活。通过`ZooKeeper`可以**大大减少系统耦合**。
  * **工作进度汇报**：通常任务被分发到不同的机器后，需要实时的将自己的任务执行进度汇报给分发系统，可以在`ZooKeeper`上选择一个节点，每个任务客户端都在这个节点下面创建临时子节点，这不仅可以判断机器是否存活，同时各个机器可以将自己的任务执行进度写到该临时子节点中去，以便中心系统能够**实时获取任务的执行进度**。
  * **系统调度**：`ZooKeeper`能够实现如下系统调度模式：分布式系统有控制台和一些客户端系统两部分构成，控制台的职责就是需要将一些指令信息发送给所有的客户端，以控制他们进行相应的业务逻辑，后台管理人员在控制台上做一些操作，实际上就是修改`ZooKeeper`上某个节点的数据，`ZooKeeper`可以把**数据变更以时间通知的形式发送给订阅客户端**。

## **5. 集群管理**

集群管理主要指**集群监控**和**集群控制**两个方面。前者侧重于集群运行时的状态的收集，后者则是对集群进行操作与控制。这样往往需要一个监控系统，实时检测集群机器的状态。

* 过去的做法通常是：监控系统通过某种手段（比如ping）定时检测每个机器，或者每个机器自己定时向监控系统汇报“我还活着”。 这种做法可行，但是存在两个比较明显的问题
  * 集群中机器有变动的时候，牵连修改的东西比较多。
  * 有一定的延时
* 目前常见做法：利用`ZooKeeper`的**节点特性**和**watcher机制**两个特性
  * 节点特性：对在zookeeper上创建的临时节点，一旦客户端与服务器之间的会话失效，那么临时节点就会被自动删除。
  * watcher机制：客户端如果对zookeeper的数据节点注册watcher监听，那么当该数据节点内容或是其子节点列表发生变更时，zookeeper服务器就会向订阅的客户端发送变更通知。
* 例：监控系统在 `/clusterServers` 节点上注册一个 `watcher`监听，那么但凡进行动态添加机器的操作，就会在 `/clusterServices` 节点下创建一个临时节点：`/clusterService/[Hostname]`，这样，监控系统就能够实时监测机器的变动情况。

## **6. Master 选举**

在分布式系统中，Master往往用来协**调集群中其他系统单元**，具有对分布式系统**状态变更的决定权**，如在读写分离的应用场景中，客户端的写请求往往是有Master来处理，或者其常常处理一些复杂的逻辑并将其处理结果同步给其他系统单元。利用`Zookeeper`的一致性，能够很好的保证在分布式高并发情况下节点的创建一定能够保证全局唯一性，即`Zookeeper`将会保证客户端无法重复创建一个已经存在的数据节点（由其保证分布式数据的一致性）。

* 实际应用
  * **在搜索系统中**，如果集群中每个机器都生产一份全量索引，不仅耗时，而且不能保证彼此之间索引数据的一致。因此让集群中的`Master`来进行全局索引的生成，然后通过到集群中的其他机器。
  * **在Hbase中**，也是使用`Zookeeper`来实现动态`HMaster`选举。在`Hbase`实现中，会在`Zookeeper`上存储一些ROOT表的地址和`HMaster`的地址，`HRegionServer`也会把即的以临时节点（Ephemeral）的方式注册在`Zookeeper`中，使得`HMaster`可以随时感知到各个`HRegionServer`的存活状态，同时，一旦`HMaster`出现问题，会重新选举出一个`HMaster`来运行，从而避免了`HMaster`的单点问题。

## **7. 分布式锁**

分布式锁是控制分布式系统之间**同步访问共享资源**的一种方式。如果不同系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，一般需要通过一些**互斥的手段**来防止彼此之间的干扰，以**保证一致性**。主要分为**排它锁**和**共享锁**。

* **排它锁**

  * 又称**写锁**或**独占锁**。如果事务 T1 对数据对象 O1 加上了排他锁，那么加锁期间，只允许事务 T1 对 O1 进行读取和更新操作。**核心是保证当前有且仅有一个事务获得锁**，并且锁释放后，所有正在等待获取锁的事务都能够被通知到。
  * **流程**
    * **1）获取锁**：在需要获取排它锁时，所有客户端通过调用接口，在 `/exclusive_lock` 节点下**创建临时子节点** `/exclusive_lock/lock`。`Zookeeper`可以**保证只有一个客户端能够创建成功**，没有成功的客户端需要注册 `/exclusive_lock`节点**监听**。
    * **2）释放锁**：当获取锁的客户端宕机或者正常完成业务逻辑都会导致**临时节点删除**，此时，所有在`/exclusive_lock`节点上注册监听的客户端都会**收到通知**，可以**重新发起分布式锁获取**。

* **共享锁**

  * 如果事务 T1 对数据对象 O1 加上了共享锁，那么当前事务 T1 只能对 O1 进行**读操作**，其他事务也只能对这个数据对象加**共享锁**，直到数据对象上的所有共享锁都被释放。
  * **流程**
    * **获取锁**：需要获得共享锁的客户端都会到 `/shared_lock` 下面创建一个**临时顺序节点**，如果是读请求，那么就创建如：`/shared_lock/host-1-R0000001`的节点，如果是写请求就创建例如：`/shared_lock/host-2-W-0000002`的节点，以此类推。
    * **判断读写顺序**：不同事务可以同时对一个数据对象进行读操作，而**更新操作**必须在当前没有任何事务进行读写情况下进行，通过`Zookeeper`来确定分布式**读写顺序**，大致分为四步：
      * 1）创建完节点后，获取`/shared_lock` 节点下所有子节点，并对该节点变更**注册监听**。
      * 2）确定自己的节点序号在所有子节点中的**顺序**。
      * 3）**对于读请求**：若没有比自己序号小或所有比自己序号小的请求都是读请求，那么表明自己已经成功获取到共享锁，同时开始执行读取逻辑，若有写请求，则需要等待。**对于写请求**：若自己不是序号最小的子节点，那么需要等待。
      * 4）接受到`Watcher`通知后，重复步骤1。
    * **释放锁**，其释放锁的流程和独占锁一致。

  * **羊群效应**：
    * 在上述描述中，host1客户端在移除自己的共享锁后，`Zookeeper`发送子节点变更`Watcher`通知给所有的机器，然后除了给host2产生影响外，对其他机器并没有任何作用。大量的`Watcher`通知和子节点列表获取连个操作会重复执行，这样会造成**系统性能影响和网络开销**，更为严重的是，如果同一时间点有多个节点对应的客户端完成了事务或事务终端引起节点的消失，`Zookeeper`服务器就会在短时间内向其他所有的客户端发送大量的事件通知，这就是所谓的**羊群效应**。 
    * 解决办法：调用 `getChildren` 接口的时候获取到所有已经创建的子节点列表，**但是这个时候不要注册任何的 Watcher**。当无法获取共享锁的时候，调用 `exist()` 来对比自己小的那个节点注册 Wathcer。相应的读写请求也会有变化（**也就是每个锁竞争者，只需要关注/shared_lock节点下序号比自己小的那个节点是否存在即可**）：
      * **读请求**: 在比自己序号小的最后一个写请求节点注册 `Watcher`。
      * **写请求**: 向比自己序号小的最后一个节点注册 `Watcher`。

## **8. 分布式队列**

分布式队列可以简单分为**先入先出队列模式**和**等待队列元素聚集后统一安排处理执行的Barrier模型**。

* **先入先出队列模式**
  * 类似于全写的共享模式，即先进入队列的请求操作先完成后，才会开始后面的请求。
  * **入队操作**就是在 `/queue_fifo` 下创建自增序的子节点，并把数据（队列大小）放入节点内。**出队操作**就是先找到 `/queue_fifo` 下序号最下的那个节点，取出数据，然后删除此节点。
  * **流程**
    * 1）通过调用`getChildren`接口来获取`/queue_fifo`节点的所有子节点，即**获取队列中的所有元素**。
    * 2）确定字节的节点序号在所有子节点中的**顺序**。
    * 3）如果自己的序号不是最小的，那么需要等待，同时向比自己小的最后一个节点注册`Watcher`监听。
    * 4）接受到`Watcher`通知后，重复步骤1
* **Barrier分布式屏障**
  * Barrier就是栅栏或者屏障，适用于这样的业务场景：**当有些操作需要并行执行，但后续操作又需要串行执行，此时必须等待所有并行执行的线程全部结束，才开始串行，于是就需要一个屏障，来控制所有线程同时开始，并等待所有线程全部结束**。
  * **实现细节**：
    * 利用 `ZooKeeper` 的实现，开始时 `queue_barrier` 节点是一个已经存在的默认节点，并且将其节点的数据内容赋值为一个数字 n 来代表 Barrier 值，比如 n=10 代表只有当 `/queue_barrier` 节点下的子节点个数达到10才会打开 Barrier。之后所有客户端都会在 `queue_barrier` 节点下创建一个临时节点，如 `queue_barrier/host1`。
    * **如何控制所有线程同时开始？** 所有的线程启动时在 `ZooKeeper` 节点 `/queue_barrier` 下插入顺序临时节点，然后检查 `/queue/barrier` 下所有 children 节点的数量是否为所有的线程数，如果不是，则等待，如果是，则开始执行。具体的步骤如下:
      * `getData()` 获取 `/queue_barrier` 节点的数据内容
      * `getChildren()` 获取 `/queue_barrier` 节点下的所有子节点，同时注册对子节点列表变更的 `Watcher` 监听。
      * 统计子节点的个数
      * 如果子节点个数不足10，那么进入等待
      * 接收 Watcher 通知后，重复2
    * **如何等待所有线程结束？** 所有线程在执行完毕后，都检查 `/queue/barrier` 下所有 children 节点数量是否为0，若不为0，则继续等待。
    * **用什么类型的节点？** 根节点使用持久节点，子节点使用临时节点，根节点为什么要用持久节点？首先因为临时节点不能有子节点，所以根节点要用持久节点，并且在程序中要判断根节点是否存在。 子节点为什么要用临时节点？临时节点随着连接的断开而消失，在程序中，虽然会删除临时节点，但可能会出现程序在节点被删除之前就 crash了，如果是持久节点，节点不会被删除。