# **一、初识**

* **消息中间件**：利用**高效可靠的消息传递机制**进行平台无关的**数据交流**，并基于**数据通信**来进行**分布式系统**的集成。
* 通过提供**消息传递**和**消息排队**模型，它可以在分布式环境下扩展进程间的通信。
* 消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有**低耦合**、**可靠投递**、**广播**、**流量控制**、**最终一致性**等一系列功能，成为**异步RPC**的主要手段之一

# **二、组成部分**

* **1）Broker**：**消息服务器**，为server提供消息核心服务
* **2）Producer**：**消息生产者**，业务的发起方，负责生产消息传输给broker
* **3）Consumer**：**消息消费者**，业务的处理方，负责从broker获取消息并进行业务逻辑处理
* **4）Topic**：**主题**，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播
* **5）Queue**：**队列**，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收
* **6）Message**：**消息体**，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输

# **三、传输模式**

消息中间件通常由**消息队列服务**、**消息传递服务**、**消息队列**和**消息应用程序接口 API** 组成，如下图所示：

![](http://img.xianzilei.cn/消息中间件的传递模型.png)

## **1. 点对点模式（P2P）**

* **点对点模型**：

  * 用于**消息生产者**和**消息消费者**之间**点到点**的通信。消息生产者将消息发送到由某个名字标识的特定消费者。这个名字实际上对于消费服务中的一个 **队列（Queue）**，在消息传递给消费者之前它被存储在这个队列中。
  * 队列消息可以放在内存中也可以**持久化**，以保证在消息服务出现故障时仍然能够传递消息。

  ![](http://img.xianzilei.cn/点对点的消息传递模式.png)

* **特点**

  * 1）**每个消息只有一个消费者**（Consumer）：即一旦被消费，消息就不再在消息队列中；
  * 2）消息的生产者和消费者之间**没有时间上的相关性**。无论消费者在生产者发送消息的时候是否处于运行状态，它都可以提取消息；
  * 3）**接受者确认消息接受和处理成功**。

## **2. 发布-订阅模式（Pub/Sub）**

* **发布者/订阅者模型**：

  * 支持向一个特定的**消息主题**生产消息，**0**或**多**个订阅者可能对接收来自特定消息主题的消息感兴趣，在这种模型下，发布者和订阅者彼此不知道对方，类似匿名公告板。
  * 这种模式被概括为：多个消费者可以获得消息。在发布者和订阅者之间**存在时间依赖性**。发布者需要建立一个订阅(subscription)，以便能够消费者订阅。订阅者必须**保持持续的活动状态**以接受消息，除非订阅者建立了持久的订阅。在这种情况下，在订阅者未连接时发布的消息将在订阅者**重新连接**时**重新发布**。

  ![](http://img.xianzilei.cn/发布订阅的消息传递模式.png)

* **特点**

  * **每个消息可以有多个订阅者**；
  * **发布者和订阅者有时间依赖**：接受者和发布者只有建立订阅关系才能收到消息；
  * **持久订阅**：订阅关系建立后，消息就不会消失，不管订阅者是否都在线；
  * **非持久订阅**：订阅者为了接收消息、必须一直在线，当只有一个订阅者时约等于点对点模式；

# **四、优缺点**

## 1. 优点

* **1）解耦**：交互系统之间没有直接的调用关系，只是通过消息传输，故系统侵入性不强，耦合度低
* **2）削峰**：使用消息中间件，并进行限流保证服务器处理的最大处理能力，将未处理的请求保存在消息队列中，避免超出服务器处理能力而宕机。在度过高峰后持续消化，即可保证服务器应对高并发情形。
* **3）异步**：使用MQ进行异步调用，可解决同步等待问题。

## 2. 缺点

* **1）系统可用性降低**：系统引入的外部依赖越多，越容易挂掉。如何保证MQ的高可用，这个问题需要特别注意。
* **2）系统复杂性提高**：需要解决一系列复杂场景问题。例如如何保证消息的不丢失，如何保证消息不被重复消费，如何控制消息的消费顺序等等。
* **3）一致性问题**：由于MQ支持异步，如何保证整个系统的一致性，也是需要注意的问题。

# **五、应用场景**

## **1. 系统解耦**

* 系统A是核心系统，能产生核心数据供下游系统B和C使用，此时常用的办法就是**A直接发送数据给B和C**，如下图所示：

  ![](http://img.xianzilei.cn/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6%E5%BA%94%E7%94%A8%E5%9B%BE-001.png)

* 随着系统的**不断扩展**，现在又扩展了下游系统D、E、F、G系统，这些系统也需要核心系统A的数据，如果按照原来的做法，系统A为例外四个系统提供接口数据，如下图所示：

  ![](http://img.xianzilei.cn/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6%E5%BA%94%E7%94%A8%E5%9B%BE-002.png)

* **问题：**如果下游系统继续扩展到上百个，此时系统A需要经常修改代码，每来一个系统需要核心数据，就需要改一次代码，而且如果某个下游系统不需要数据了，系统A也需要删除对该下游系统发送数据的代码，这样导致**系统间耦合度过高**。

* **解决：**如果提供消息中间件作为中间层，系统A只需要负责将数据发送到MQ中，下游系统根据自身的需求从MQ中获取消息，如果不需要数据直接不取即可，这样**大大降低了系统间的耦合度**。如下图所示：

  ![](http://img.xianzilei.cn/%E7%B3%BB%E7%BB%9F%E8%A7%A3%E8%80%A6%E5%BA%94%E7%94%A8%E5%9B%BE-004.png)

## **2. 异步调用**

* 某个一业务线的系统调用链路为系统A调用B（耗时20ms），然后系统B调用系统C（耗时20ms），最近系统C调用系统D（耗时2s），如下图所示

  ![](http://img.xianzilei.cn/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E5%BA%94%E7%94%A8%E5%9B%BE-001.png)

* **问题**：总业务耗时2040ms，其中主要耗时在C到D的过程。这样会导致A、B、C平白无故多等2s时间，**整个系统的性能降低**。

* **解决**：将系统C调用系统D抽离出来，使用MQ实现异步调用。这样可以使整个系统的性能提高约50倍，如下图所示

  ![](http://img.xianzilei.cn/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E5%BA%94%E7%94%A8%E5%9B%BE-002.png)

## **3. 削峰填谷**

* 某一系统平常每秒约几百多请求，部署在一台服务器上，运行起来基本没有问题。

* 由于双十一的来临，网站做活动，平常访问量还是每秒几百多请求，但是高峰期达到了几千，常见做法是进行**负载均衡**，**扩充机器**来分摊请求。如下图所示：

  ![](http://img.xianzilei.cn/%E5%89%8A%E5%B3%B0%E5%A1%AB%E8%B0%B7%E5%BA%94%E7%94%A8%E5%9B%BE-001.png)

* **问题**：但是由于每天的高峰期不过几十分钟，扩充到三天机器，平时也就每台机器每秒处理不到一百的请求，导致**资源的严重浪费**。如下图所示：

  ![](http://img.xianzilei.cn/%E5%89%8A%E5%B3%B0%E5%A1%AB%E8%B0%B7%E5%BA%94%E7%94%A8%E5%9B%BE-002.png)

* **解决**：可以考虑引入MQ来进行流量削峰，可以只部署一台服务器，将**所有请求通过消息中间件**，机器安装自己的最大负荷来消费消息队列中的数据，等流量高峰过来，慢慢地队列中的消息也就消费完毕了。此时达到了**削峰填谷**的作用。如下图所示：

  ![](http://img.xianzilei.cn/%E5%89%8A%E5%B3%B0%E5%A1%AB%E8%B0%B7%E5%BA%94%E7%94%A8%E5%9B%BE-003.png)

## **4. 日志处理**

* 将消息队列用在**日志处理**中，比如 `Kafka` 的应用，解决 **海量日志**传输和缓冲的问题

* 例如：把日志进行集中收集，用于计算 `PV`、**用户行为分析**

  ![](http://img.xianzilei.cn/%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86%E5%BA%94%E7%94%A8%E5%9B%BE-004.png)

## **5. 顺序保证**

在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是**排序**的，并且能保证数据会按照特定的顺序来处理。

## **6. 消息通讯**

消息队列一般都**内置了高效的通信机制**，因此也可以用于单纯的 消息通讯，比如实现点对点消息队列或者聊天室 等。

# **六、常用协议**

* **1）AMQP协议**
  * **AMQP（Advanced Message Queuing Protocol）**：一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。
  * **优点**：可靠、通用
* **2）MQTT协议**
  * **MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）**：是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。
  * **优点**：格式简洁、占用带宽小、移动端通信、PUSH、嵌入式系统
* **3）STOMP协议**
  * **STOMP（Streaming Text Orientated Message Protocol）**：是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。
  * **优点**：命令模式（非topic\queue模式）
* **4）XMPP协议**
  * **XMPP（可扩展消息处理现场协议，Extensible Messaging and Presence Protocol）**：是基于可扩展标记语言（XML）的协议，多用于即时消息（IM）以及在线现场探测。适用于服务器之间的准即时操作。核心是基于XML流传输，这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。
  * **优点**：通用公开、兼容性强、可扩展、安全性高，但XML编码格式占用带宽大

* **5）其他基于TCP/IP自定义的协议**

  有些特殊框架（如：redis、kafka、zeroMq等）根据自身需要未严格遵循MQ规范，而是基于TCP\IP自行封装了一套协议，通过网络socket接口进行传输，实现了MQ的功能。

# **七、常见的消息中间件介绍及选型**

## **1. 常见的消息中间件**

* **ActiveMQ**
  * `ActiveMQ`是由Apache出品，`ActiveMQ`是一个完全支持JMS1.1和J2EE 1.4规范的JMS Provider实现。它非常快速，支持多种语言的客户端和协议，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能。
  * **主要特性：**
    * **服从JMS规范**：JMS 规范提供了良好的标准和保证，包括：同步 或 异步 的消息分发，一次和仅一次的消息分发，消息接收和订阅等等。遵从JMS规范的好处在于，不论使用什么JMS实现提供者，这些基础特性都是可用的；
    * **连接灵活性**：`ActiveMQ`提供了广泛的连接协议，支持的协议有：HTTP/S，IP多播，SSL，TCP，UDP等等。对众多协议的支持让`ActiveMQ`拥有了很好的灵活性；
    * **支持的协议种类多**：`OpenWire`、`STOMP`、`REST`、`XMPP`、`AMQP`；
    * **持久化插件和安全插件**：`ActiveMQ`提供了多种持久化选择。而且，`ActiveMQ`的安全性也可以完全依据用户需求进行自定义鉴权和授权；
    * **支持的客户端语言种类多**：除了Java之外，还有：C/C++，.NET，Perl，PHP，Python，Ruby；
    * **代理集群**：多个`ActiveMQ`代理可以组成一个集群来提供服务；
    * **异常简单的管理**：`ActiveMQ`是以开发者思维被设计的。所以，它并不需要专门的管理员，因为它提供了简单又使用的管理特性。有很多中方法可以监控`ActiveMQ`不同层面的数据，包括使用在`JConsole`或者在`ActiveMQ`的`WebConsole`中使用JMX。通过处理JMX的告警消息，通过使用命令行脚本，甚至可以通过监控各种类型的日志。
  * **优点：**
    * **跨平台**(JAVA编写与平台无关，`ActiveMQ`几乎可以运行在任何的JVM上)；
    * **可以用JDBC**：可以将数据持久化到数据库。虽然使用JDBC会降低`ActiveMQ`的性能，但是数据库一直都是开发人员最熟悉的存储介质；
    * **支持JMS规范**：支持JMS规范提供的统一接口;
    * **支持自动重连和错误重试机制**；
    * **有安全机制**：支持基于`shiro`，`jaas`等多种安全配置机制，可以对Queue/Topic进行认证和授权；
    * **监控完善**：拥有完善的监控，包括`WebConsole`，`JMX`，`Shell`命令行，`Jolokia`的RESTful API；
    * **界面友善**：提供的`WebConsole`可以满足大部分情况，还有很多第三方的组件可以使用，比如`hawtio`。
  * **缺点：**
    * 社区活跃度不及RabbitMQ高；
    * 根据其他用户反馈，会出莫名其妙的问题，会丢失消息；
    * 目前重心放到activemq6.0产品Apollo，对5.x的维护较少；
    * 不适合用于上千个队列的应用场景。
* **RabbitMQ**
  * `RabbitMQ`于2007年发布，是一个在`AMQP`(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。
  * **主要特性：**
    * **可靠性**：提供了多种技术可以让你在性能和可靠性之间进行权衡。这些技术包括持久性机制、投递确认、发布者证实和高可用性机制；
    * **灵活的路由**：消息在到达队列前是通过交换机进行路由的。`RabbitMQ`为典型的路由逻辑提供了多种内置交换机类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做`RabbitMQ`的插件来使用；
    * **消息集群**：在相同局域网中的多个`RabbitMQ`服务器可以聚合在一起，作为一个独立的逻辑代理来使用；
    * **队列高可用**：队列可以在集群中的机器上进行镜像，以确保在硬件问题下还保证消息安全；
    * **支持多种协议**：支持多种消息队列协议；
    * **支持多种语言**：用`Erlang`语言编写，支持只要是你能想到的所有编程语言；
    * **管理界面**：`RabbitMQ`有一个易用的用户界面，使得用户可以监控和管理消息Broker的许多方面；
    * **跟踪机制**：如果消息异常，`RabbitMQ` 提供消息跟踪机制，使用者可以找出发生了什么；
    * **插件机制**：提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。
  * **优点：**
    * 由于Erlang语言的特性，**消息队列性能较好**，**支持高并发**；
    * **健壮**、**稳定**、**易用**、**跨平台**、**支持多种语言**、**文档齐全**；
    * 有**消息确认机制**和**持久化机制**，**可靠性高**；
    * **高度可定制的路由**；
    * **管理界面较丰富**，在互联网公司也有较大规模的应用，**社区活跃度高**。
  * **缺点：**
    * 尽管结合 Erlang 语言本身的并发优势，性能较好，但是不利于做二次开发和维护；
    * 实现了代理架构，意味着消息在发送到客户端之前可以在中央节点上排队。此特性使得`RabbitMQ`易于使用和部署，但是使得其运行速度较慢，因为中央节点 增加了延迟，消息封装后也比较大；
    * 需要学习比较复杂的接口和协议，学习和维护成本较高。
* **RocketMQ**
  - `RocketMQ`出自阿里的开源产品，用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进，消息可靠性上比Kafka更好。`RocketMQ`在阿里内部被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，`binglog`分发等场景。
  - **主要特性：**
    * **基于队列模型**：具有高性能、高可靠、高实时、分布式等特点；
    * **Producer、Consumer、队列都支持分布式**；
    * **Producer向一些队列轮流发送消息，队列集合称为Topic。Consumer如果做广播消费，则一个Consumer实例消费这个Topic对应的所有队列；如果做集群消费，则多个Consumer 实例平均消费这个Topic对应的队列集合**；
    * **能够保证严格的消息顺序**
    * **提供丰富的消息拉取模式**
    * **高效的订阅者水平扩展能力**
    * **实时的消息订阅机制**
    * **亿级消息堆积 能力**
    * **较少的外部依赖**。
  - **优点：**
    * 单机支持**1万以上持久化队列**；
    * RocketMQ的所有消息都是持久化的，先写入系统PAGECACHE，然后刷盘，可以保证内存与磁盘都有一份数据，而访问时，直接从**内存读取**。
    * **模型简单**，**接口易用**（JMS的接口很多场合并不太实用）；
    * **性能非常好**，可以允许大量堆积消息在Broker中；
    * **支持多种消费模式**，包括集群消费、广播消费等；
    * 各个环节分布式扩展设计，支持**主从**和**高可用**；
    * **开发度较活跃**，版本更新很快。
  - **缺点：**
    * 支持的客户端语言不多，目前是Java及C++，其中C++还不成熟；
    * `RocketMQ`社区关注度及成熟度不高；
    * 没有Web管理界面，提供了一个 CLI (命令行界面) 管理工具带来查询、管理和诊断各种问题；
    * 没有在MQ核心里实现JMS等接口；
* **Kafka**
  - `Apache Kafka`是一个分布式消息发布订阅系统。它最初由`LinkedIn`公司基于独特的设计实现为一个分布式的日志提交系统(`a distributed commit log`)，之后成为Apache项目的一部分。Kafka性能高效、可扩展良好并且可持久化。它的分区特性，可复制和可容错都是其不错的特性。
  - **主要特性：**
    * **快速持久化**：可以在O(1)的系统开销下进行消息持久化；
    * **高吞吐**：在一台普通的服务器上既可以达到10W/s的吞吐速率；
    * **完全的分布式系统**：Broker、Producer和Consumer都原生自动支持分布式，自动实现负载均衡；
    * 支持**同步**和**异步复制**两种高可用机制；
    * 支持**数据批量发送和拉取**；
    * **零拷贝技术(zero-copy)：**减少IO操作步骤，提高系统吞吐量；
    * **数据迁移**、**扩容**对用户透明；
    * **无需停机即可扩展机器**；
    * **其他特性**：丰富的消息拉取模型、高效订阅者水平扩展、实时的消息订阅、亿级的消息堆积能力、定期删除机制；
  - **优点：**
    * **客户端语言丰富**：支持Java、.Net、PHP、Ruby、Python、Go等多种语言；
    * **高性能**：单机写入TPS约在100万条/秒，消息大小10个字节；
    * **提供完全分布式架构，并有replica机制**，拥有较高的可用性和可靠性，理论上支持消息无限堆积；
    * **支持批量操作**；
    * **消费者采用Pull方式获取消息**。消息有序，通过控制能够保证所有消息被消费且仅被消费一次；
    * **有优秀的第三方KafkaWeb管理界面Kafka-Manager**；
    * **在日志领域比较成熟**，被多家公司和多个开源项目使用。
  - **缺点：**
    * Kafka单机超过64个队列/分区时，Load时会发生明显的飙高现象。队列越多，负载越高，发送消息响应时间变长；
    * 使用短轮询方式，实时性取决于轮询间隔时间；
    * 消费失败不支持重试；
    * 支持消息顺序，但是一台代理宕机后，就会产生消息乱序；
    * 社区更新较慢。

## **2. 消息中间件选型**

* **从公司基础建设力量角度：**
  * **中小型软件公司**：建议选`RabbitMQ`，一方面，erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。他的弊端也在这里，虽然RabbitMQ是开源的，然而国内有几个能定制化开发erlang的程序员呢？所幸，`RabbitMQ`的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。不考虑`RocketMQ`和`kafka`的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以`kafka`排除。不考虑`RocketMQ`的原因是，`RocketMQ`是阿里出品，如果阿里放弃维护`RocketMQ`，中小型公司一般抽不出人来进行`RocketMQ`的定制化开发，因此不推荐。
  * **大型软件公司**：根据具体使用在`RocketMQ`和`kafka`之间二选一。一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。针对`RocketMQ`,大型软件公司也可以抽出人手对`RocketMQ`进行定制化开发，毕竟国内有能力改JAVA源码的人，还是相当多的。至于`kafka`，根据业务场景选择，如果有日志采集功能，肯定是首选`kafka`了。
* **从业务场景角度出发：**
  * **RocketMQ**定位于非日志的可靠消息传输（日志场景也OK），目前`RocketMQ`在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，`binglog`分发等场景。
  * **Kafka**是`LinkedIn`开源的分布式发布-订阅消息系统，目前归属于Apache定级项目。`Kafka`主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输。0.8版本开始支持复制，不支持事务，对消息的重复、丢失、错误没有严格要求，适合产生大量数据的互联网服务的数据收集业务。
  * **RabbitMQ**是使用`Erlang`语言开发的开源消息队列系统，基于`AMQP`协议来实现。`AMQP`的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。`AMQP`协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。