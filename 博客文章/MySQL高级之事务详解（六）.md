# **一、事务初识**

## **1. 什么是事务**

>  事务就是一组独立不可分割的工作单元，事务中的操作要么全部执行，要么都不执行。

* 事务是数据库操作的**最小工作单元**，是作为单个逻辑工作单元执行的一系列操作，**一组不可再分割的操作集合（工作逻辑单元）。**
* 简单来说，事务就是**并发控制**的单位，是用户定义的一个操作序列。

* 在**关系型数据库**中，一个事务可以是**一条SQL语句**，**一组SQL语句**或**整个程序**。
* **MySQL中，MyISAM引擎没有实现事务，而InnoDB实现了事务，这也是MyISAM 逐渐被InnoDB 所替代的原因之一**。

## **2. 为什么要有事务**

如果之前没有了解过事务，看了上面事务的介绍的小伙伴，想必还是不理解事务到底是什么东东吧。**那么接下来就从经典的转账操作案例来分析什么是事务以及为什么要使用事务**。

* 假设你的朋友手头紧向你借1000元，你本着多年的友情毫不犹豫地给你朋友转了1000元，上述的过程可以拆分为以下三个步骤（假设A为我，B为你的朋友）：
  * 1）A发起转账1000给B
  * 2）A账户余额减少1000
  * 3）B账户余额增加1000
* 如果没有使用事务，每一步正常执行，那没什么问题。但是如果1,2步骤成功，第3步骤由于网络或其余故障导致执行失败，那么就会发生A账户钱减少了，但是B账户钱并没有增加，那么此时你的朋友就会说没有收到哇，你此时也会有疑问，甚至恼火抱怨银行怎么这么不靠谱，平白无故损失1000元。
* 所以这时候事务闪亮登场，将2,3步骤整合到一个事务中，这样即使2成功，3失败，由于事务的同甘共苦（一起成功，一起失败）特性，2的操作也会回滚。最终也不会有任何的损失。

# **二、事务的四大特性**

**提到事务首先想到的当然是事务的四个特性：原子性、一致性、隔离性、持久性，即所谓的ACID**。

## **1. A(Atomicity) 原子性**

**原子性指的是事务是不可分割的工作单位，只有事务中的所有的数据库操作都执行成功，才算整个事务成功**。事务中任何一个SQL执行失败，已经执行成功的SQL语句也必须撤销，回滚到执行事务的之前的状态。例如上述的转账操作，2，3步骤必须全部执行成功才算事务成功，否则一旦其中某一个操作执行失败，整个事务必须全部回滚到之前的状态。

## **2. C(Consistency) 一致性**

**一致性是指事务将数据库从一种一致性状态变为下一种一致性状态。在事务开始之前和之后，数据库的完整性约束没有被破坏**。例如上述转账的例子，无论转账的成功与否，A和B加起来的总额不会变化，不多也不少。

## **3. I(Isolation) 隔离性**

**隔离性要求每个读写事务对其他事务的操作对象能相互分离。**例如事务T1和事务T2的操作不能相互干扰。

## **4. D(Durability) 持久性**

**一个事务成功完成后，它对数据库的改变必须是永久的**，即使事务刚提交机器就宕机了数据也不能丢。事务终结的标志即内存的数据持久到硬盘文件中。

# **三、事务的隔离级别**

## **1. 事务的并发问题**

当**多个事务并发执行**时可能出现如下的问题：

* **丢失修改**

  指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为**丢失修改**。类似多线程并发修改同一个数据。

* **脏读**

  即**事务读取到其他事务未提交的数据**。当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

* **不可重复读**

  即**事务两次读取到的数据不一样**。指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

* **幻读**

  **幻读与不可重复读类似**。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**注意：不可重复读是指多次读取一条记录发现其中某些列的值被修改，而幻读则指的是多次读取一条记录发现记录增多或减少了。**

## **2. 事务隔离级别分类**

**为了解决上述并发事务带来的问题，数据库引入了四种不同的隔离级别。**

### **2.1 RU(READ-UNCOMMITTED)读未提交**

即**一个事务可以读取到另一个未提交事务修改过的数据**。很明显这样的隔离级别会造成脏读这样的严重问题，一般不使用。

### **2.2 RC(READ COMMITTED)读已提交**

**一个事务提交后，其更改才能被其他事务所看到**。即事务只能读取别的事务已经提交的数据。这种隔离级别可以避免脏读的问题，但是可能会有不可重复读和幻读的问题。**这也是Oracle默认的隔离级别**。

### **2.3 RR(REPEATABLE READ)可重复读**

**在一个事务中，多次读取同一个数据得到的结果总是相同的，即使有其他事务更新了这个数据并提交成功了也不会变**。可重复读解决了不可重复读的问题。但是还是会出现幻读。InnoDB 引擎通过多版本并发控制（Multiversion concurrency control，MVCC）解决了幻读的问题。这也是**MySQL默认的隔离级别**。

### **2.4 (SERIALIZABLE)串行化**

顾名思义，即**事务串行执行**。它是**最严格的隔离级别**，在事务中对读操作加读锁，对写操作加写锁，所以可能会出现大量锁争用的场景。

## **3. 各个隔离级别下的可能带来的问题**

| 事务隔离级别 |    脏读    | 不可重复读 |                 幻读                 |
| :----------: | :--------: | :--------: | :----------------------------------: |
| **未提交读** |  可能发生  |  可能发生  |               可能发生               |
| **已提交读** | 不可能发生 |  可能发生  |               可能发生               |
| **可重复读** | 不可能发生 | 不可能发生 | 可能发生（**对于InnoDB不可能发生**） |
|  **串行化**  | 不可能发生 | 不可能发生 |              不可能发生              |

# **四、事务的使用**

* **显示开启一个事务**

  ```sql
  begin;
  或
  start transaction;
  ```

* **提交事务**

  ```sql
  commit;
  ```

* **回滚事务**

  ```sql
  rollback;
  ```

* **在事务中创建一个保存点**

  ```sql
  savepoint [unique flag];
  ```

* **删除事务保存点**

  ```sql
  release savepoint [unique flag];
  ```

* **回滚到事务某个保存点**

  ```sql
  rollback to savepoint [unique flag];
  ```

* **查看事务隔离级别**

  ```sql
  --查看当前会话隔离级别
  select @@tx_isolation;
  
  --查看系统当前隔离级别
  select @@global.tx_isolation;
  ```

* **修改事务隔离级别**

  ```sql
  --设置当前会话隔离级别
  set session transaction isolatin level [事务隔离级别，例如repeatable read];
  
  --设置系统当前隔离级别
  set global transaction isolation level [事务隔离级别，例如repeatable read];
  
  --设置当前会话的事务是否自动提交，0-否，1-是
  set autocommit=0/1;
  ```

# **五、事务的实现**

MySQL中，事务是通过**redo_log**、**undo_log**和**锁**来实现的，其中**redo_log 实现持久化和原子性**，**undo_log实现一致性**，**锁实现隔离性**。其中**redo_log是恢复提交事务修改的页操作**，而**undo_log是回滚行记录到特定版本**，二者记录的内容也不同，`redo_log`是**物理日志，记录页的物理修改操作**，而`undo_log`是**逻辑日志，根据每行记录进行记录**。关于锁的实现可以参考之前写的文章：[MySQL高级之锁机制详解（五）](http://xianzilei.cn/blog/38)，这里不再赘述。下面就这两个日志进行详细说明。

## **1. redo log**

`redo_log`重做日志主要**用来实现持久化和原子性**，重做日志由两部分组成，一是内存中的**重做日志缓存(redo log buffer)**，这部分是**容易丢失**的。二是**重做日志文件(redo log file)**，这部分是**持久**的。

### **1.1 更新流程**

![](http://img.xianzilei.cn/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B.png)

其中每一步操作如下

* ① 执行update操作
* ② 将原始数据从磁盘读取到内存，根据update操作修改内存中的数据。
* ③ 生成一条重做日志写入redo log buffer，记录数据被修改后的值。
* ④ 当事务提交时，将redo log buffer中的内容刷新到redo log file。
* ⑤ 事务提交后，将内存中修改数据的值写入磁盘

在**每次将redo log buffer写入redo log file后，都需要调用一次fsync操作**，因为重做日志缓冲只是把内容先写入操作系统的缓冲系统中，并没有确保直接写入到磁盘上，所以必须进行一次`fsync`操作。因此，**磁盘的性能在一定程度上也决定了事务提交的性能**。

### **1.2 恢复机制**

![](http://img.xianzilei.cn/%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6.png)

如上图所示，其中LSN，即Log Sequence Numbe，指的是日志序列号，它代表的含义有: 重做日志写入的总量、checkpoint的位置、页的版本。在Innodb里，LSN占8个字节，且是单调递增的。

假设在`LSN=10000`的时候数据库出现故障，磁盘中`checkpoint`为10000，表示磁盘已经刷新到10000这个序列号，当前`redo log`的`checkpoint`是13000，则需要恢复10000-13000的数据。

### **1.3 总结**

上面两节就是redo log的更新和恢复机制，总结一下redo log为什么可以实现事务的原子性和持久性。

* **原子性**：**redo log记录了事务期间操作的物理日志**，事务提交之前，并没有写入磁盘，保存在内存里，如果事务失败，数据库磁盘不会有影响，回滚掉事务内存部分即可。
* **持久性**：**redo log 会在事务提交时将日志存储到磁盘redo log file**，保证日志的持久性。

## **2. undo log**

redo log记录了事务的行为，可以很好地提供对页进行重做操作。但是事务有时需要进行回滚，这就需要undo。**undo_log有两个功能，一是提供回滚，二是实现MVCC机制**（如果不了解MVCC机制，请看之前的文章：[MYSQL高级之MVCC机制详解（七）](http://xianzilei.cn/blog/40)）。undo log和redo log记录物理日志不一样，它是**逻辑日志**。它实际上做的是**与先前相反的操作**。即当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。**redo存放在重做日志文件中，但是undo存放在数据库内部的一个特殊段上，这个段称为undo段，存在于共享空间内**。

* **当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚**
* **当应用到行版本控制的时候，也是通过undo log来实现的：当读取的某一行被其他事务锁定时，它可以从undo log中分析出该行记录以前的数据是什么，从而提供该行版本信息，让用户实现非锁定一致性读取。**