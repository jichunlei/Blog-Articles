# **一、前言**

## **1. SQL执行慢的原因**

* **从sql本身角度来说**
  * 没有创建索引
  * **索引失效**（一些原因导致没有使用到）
  * **关联查询太多的join**
* **从服务器角度来说**
  * 服务器磁盘空间不足
  * 服务器**调优配置参数设置不合理**

## **2. 如何优化**

接下来将从**关联查询join优化**和**索引优化**两个个方面进行讲解

# **二、MySQL性能分析工具**

在讲解优化前，先介绍MySQL几个性能分析工具。

## **1. Explain**

**MySQL查看sql执行计划的关键字**，使用explain关键字可以模拟优化器执行sql查询语句，从而得知MySQL 是如何处理sql语句。

### 1.1 语法

```sql
explain <sql语句>
```

### 1.2 结果详解

执行查看执行计划语句后返回如下10列（**MySQL5.5.48版本**）

```tex
+----+-------------+-----------+------+---------------+------+---------+------+------+-------+
| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-----------+------+---------------+------+---------+------+------+---
```

* **id**：select 查询的**序列号**，包含一组可以重复的数字，表示查询中执行sql语句的顺序。一般以下三种情况
  * **id全部相同**：sql的执行顺序是由上到下执行
  * **id全部不同**：sql的执行顺序是id大有限执行
  * **id既存在相同，也存在不同**：先根据id大优先执行，再根据id相同由上到下执行
* **select_type**：select 查询的类型，主要是用于区别普通查询，联合查询，嵌套的复杂查询，主要包含以下几种类型
  * **SIMPLE**：**简单查询**，查询中不包含子查询或者UNION
  * **PRIMARY**：**主查询**，查询中若包含任何复杂的子部分，最外层查询则被标记为该类型
  * **SUBQUERY**：**子查询**，在SELECT或者WHERE列表中包含了的子查询
  * **DERIVED**：**衍生查询**，在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放在临时表里。
  * **UNION**：**联合查询**，有UNION的第二个和以后的查询
  * **UNION RESULT**：从UNION表获取结果的SELECT
* **table**：显示这一行的数据是关于哪张表的，对应衍生查询则表名为`derived+id`

* **type**：对表访问方式，主要包含以下几种

  * **system**：表中只有一行数据，这是const类型的特例。
  * **const**：表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键至于where列表中，MySQL就能将该查询转换为一个常量。
  * **eq_ref**：唯一性索引，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描。简单来说，就是多表连接中使用primary key或者 unique key作为关联条件。
  * **ref**：非唯一索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而它可能会找到多个符合条件的行。
  * **range**：只检索给定范围的行，使用一个索引来选择行。一般出现在where语句中出现了between、<、>、in等的查询，这种范围扫描索引扫描比全表扫描要好，因为他只需要开始索引的某一点，而结束语另一点，不用扫描全部索引。
  * **index**：Full Index Scan。index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）
  * **all**：Full Table Scan。将遍历全表以找到匹配的行

  **性能从最优到最差的排序：system > const > eq_ref > ref > range > index > all**，一般来说，尽量优化查询达到range级别，最好达到ref。

* **possible_keys**：显示查询语句可能用到的索引(一个或多个或为null)，不一定被查询实际使用。仅供参考使用

* **key**：显示查询语句实际使用的索引。若为null，则表示没有使用索引。

* **key_len**：显示索引中使用的字节数，可通过key_len计算查询中使用的索引长度。在不损失精确性的情况下索引长度越短越好。key_len 显示的值为索引字段的最可能长度，并非实际使用长度，即key_len是根据表定义计算而得，并不是通过表内检索出的。

* **ref**：列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值

* **rows**：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数

* **Extra**：包含不适合在其他列中显示但十分重要的额外信息，主要包括以下几种：

  * **Using filesort**：说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序” 。出现这个就要立刻优化sql。
  * **Using temporary**：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序 order by 和 分组查询 group by。 出现这个更要立刻优化sql
  * **Using index**：表示相应的select 操作中使用了覆盖索引（Covering index），避免访问了表的数据行，效果不错！如果同时出现Using where，表明索引被用来执行索引键值的查找。如果没有同时出现Using where，表示索引用来读取数据而非执行查找动作。覆盖索引（Covering Index） ：也叫索引覆盖，就是select 的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select 列表中的字段，而不必根据索引再次读取数据文件。
  * **Using where**：表明使用了where 过滤
  * **Using join buffer**：表明使用了连接缓存
  * **Impossible where**：where 语句的值总是false，不可用，不能用来获取任何元素
  * **select tables optimized away**：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者
    对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，
    查询执行计划生成的阶段即完成优化。
  * **distinct**：优化distinct，在找到第一匹配的元组后即停止找同样值的工作

## **2. 慢查询日志**

## **3. Show profiles**

# **三、JOIN优化**

# **四、索引优化**